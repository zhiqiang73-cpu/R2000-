# R3000 量化系统技术栈说明 · AI 复现指南

> **目标读者**：其他 AI 开发者。本文档用于帮助 AI 理解、复现 R3000 项目的核心逻辑，不包含已淘汰功能（指纹图、自适应等）。

---

## 一、项目概述

R3000 是一个**基于止盈止损推理胜率 → 策略验证 → 策略分层去重 → 多轮次发现 → 回测 → 模拟交易**的量化 MVP 系统。

**核心流程**：
1. 用固定 TP/SL 预计算每根 K 线的「止盈先触发 / 止损先触发」结果
2. 用技术指标条件组合筛选出高胜率策略
3. 多轮分析累积，按层级（候选/优质/精品）和稳定性评分
4. 策略去重、分层筛选，得到精品池
5. 回测验证 → 模拟交易执行

---

## 二、技术栈

### 2.1 运行环境

- **Python**：3.10+（建议 3.11）
- **操作系统**：Windows / Linux

### 2.2 核心依赖（requirements.txt）

```
PyQt6>=6.4.0          # UI 框架
pyqtgraph>=0.13.0     # 图表
pandas>=2.0.0         # 数据处理
numpy>=1.24.0         # 数值计算
pyarrow>=12.0.0       # Parquet 数据
scikit-learn>=1.3.0   # 特征重要性（可选）
matplotlib>=3.7.0     # 分析图表
scipy>=1.10.0
numba>=0.57.0         # 加速
orjson>=3.9.0         # 高速 JSON
```

### 2.3 项目结构（核心模块）

```
R3000/
├── main.py                 # 入口，PyQt6 深色主题
├── config.py               # 全局配置（TP/SL、门槛、池参数等）
├── core/
│   ├── signal_analyzer.py  # 信号组合分析（止盈止损推理 + 胜率计算）
│   ├── signal_store.py    # 策略持久化、多轮合并、去重、分层
│   ├── signal_live_monitor.py  # 实时检测策略组合是否触发
│   ├── market_state_detector.py  # 市场状态（多头/空头/震荡）
│   ├── backtester.py      # 回测引擎
│   ├── paper_trader.py    # 模拟交易（虚拟订单、止盈止损）
│   ├── live_trading_engine.py   # 实盘/模拟交易主引擎
│   ├── data_loader.py     # K 线加载
│   └── ...
├── utils/
│   └── indicators.py      # 技术指标（RSI、KDJ、MACD、ATR、布林等）
├── ui/
│   ├── main_window.py
│   ├── signal_analysis_tab.py   # 信号分析 UI
│   ├── paper_trading_tab.py     # 模拟交易 UI
│   └── ...
└── data/
    ├── signal_analysis_state.json      # Pool1 状态
    ├── signal_analysis_state_pool2.json
    ├── signal_cumulative_cache.json    # Pool1 去重后缓存
    └── signal_cumulative_cache_pool2.json
```

---

## 三、核心流程详解

### 3.1 止盈止损 → 胜率推理（signal_analyzer.py）

**核心思想**：对每个 bar 假设「在 bar i 收盘后发出信号、于 bar i+1 开盘入场」，用固定 TP/SL 价格判断「止盈先触发」还是「止损先触发」。

**参数**（Pool1 / Pool2 不同）：

| 方向 | TP（价格%） | SL（价格%） | 含费后随机基准 |
|------|-------------|-------------|----------------|
| 做多 Pool1 | +0.6% | -0.8% | 61% |
| 做空 Pool1 | -0.8% | +0.6% | 47% |
| 做多/做空 Pool2 | ±1.0% | ±0.8% | 约 47.8% break-even |

**实现**：`_precompute_outcomes(high, low, open, close, direction, tp_pct, sl_pct, max_hold=60)`

- 入场价 = `open[i+1]`
- TP 价：做多 `entry*(1+tp_pct)`，做空 `entry*(1-tp_pct)`
- SL 价：做多 `entry*(1-sl_pct)`，做空 `entry*(1+sl_pct)`
- 在 `entry_idx` 到 `entry_idx+max_hold` 内逐根 K 线检查 `high/low` 是否触及 TP/SL
- **同 K 线双触发**：悲观假设，一律视为止损（False）
- **超时**：max_hold 根内未触发 → 未命中

**返回**：`(outcomes: bool[], hold_bars: int[])`，`outcomes[i]=True` 表示该 bar 信号止盈先触发。

---

### 3.2 条件组合与胜率门槛（signal_analyzer.py）

**条件池**：每方向约 30 个条件（宽松/严格各 9 个极端 + 12 个温和），例如：

- 极端：`rsi_loose`/`rsi_strict`、`k_loose`/`k_strict`、`atr_ratio_loose`/`atr_ratio_strict`、`close_vs_ma5`、`consec_bear`、`vol_ratio`、`boll_pos`、`lower_shd` 等
- 温和：`rsi_mod`、`boll_pos_mod`、`macd_hist_turn`、`close_vs_ma5_mod`、`ma5_slope_dir`、`obv_trend`、`vol_ratio_mod` 等

**预剪枝**：仅保留 `trigger_count >= MIN_TRIGGERS(8)` 的条件，**不做单条件命中率筛选**（数据量大时单条件命中率收敛至随机基准，命中率剪枝会误杀所有条件）。

**组合筛选**：用 `itertools.combinations` 生成 2~5 条件组合，对每个组合：

- 条件 AND：所有条件在 bar i 同时满足 → 触发
- `hit_rate = sum(outcomes[trigger_indices]) / len(trigger_indices)`
- 门槛：做多 64%/67%/71%，做空 52%/55%/59% 对应候选/优质/精品

**市场状态**：按 ADX + MA5 斜率分为「多头趋势」「空头趋势」「震荡市」，每个状态单独统计命中率。

---

### 3.3 策略分层与多轮累积（signal_store.py）

**合并**：每轮 `analyze()` 结果通过 `merge_rounds(long_results, short_results, pool_id)` 写入 cumulative：

- `combo_key` = `"{direction}|{条件1}+{条件2}+..."`（条件按字典序，保证唯一性）
- 每条 entry 必须带 `pool_id`（`'pool1'` 或 `'pool2'`）
- `history` 追加：`round_id`, `hit_rate`, `trigger_count`, `hit_count`, `market_state_breakdown`, `hold_bars`

**累计指标**：

- `appear_rounds`：出现轮次
- `avg_rate`：各轮平均命中率
- `rate_std`：命中率标准差
- `stability_score` = `avg_rate × (1 - rate_std) × ln(appear_rounds + 1)`
- `综合评分`：命中率 30% + 稳定性 40% + 轮次 30%，0–100 分
- `avg_hold_bars`：自然结束交易的平均持仓根数（中位数，排除超时）
- `hold_bars_sample_count`：参与统计的有效样本数

**层级**：`_tier_from_rate(overall_rate, direction)` 对应候选/优质/精品。

---

### 3.4 策略去重（signal_store.py）

**1. 条件规范化** `_normalize_all_entries`：同族同时含宽松+严格时，只保留严格版。

**2. 冗余子集剪枝** `_prune_redundant_subsets`：

- 若 A 覆盖 B（A 条件更少且逻辑覆盖 B）且 A 命中率 ≥ B，则删除 B
- 覆盖定义：`_cond_covers(ca, cb)`：同族且宽松覆盖严格

**3. 锚点分组去重** `_anchor_dedup`：

- 同方向、共享同一「锚定条件」（高频条件）的策略，按综合评分保留 Top 4
- 互补保护：主导市场状态不同则不计入同一限额

**4. 负期望策略排除**：`ev = rate * tp_pct - (1-rate) * sl_pct <= 0` 直接排除。

---

### 3.5 多轮次发现策略与 70/30 验证

**流程**：

1. 用户加载 K 线（如 50000 根），点击「分析」
2. `SignalAnalysisWorker` 后台依次调用 `analyze(df, 'long', pool1)`、`analyze(df, 'short', pool1)`、`analyze(df, 'long', pool2)`、`analyze(df, 'short', pool2)`
3. 每轮结果 `merge_rounds` 合并到 `signal_store`
4. 合并完成后调用 `rebuild_pruned_cache(pool1)`、`rebuild_pruned_cache(pool2)` 执行去重并更新缓存

**多轮**：多轮使用不同采样（不同时间段或随机采样）可提高泛化，避免过拟合单一时间段。

**70/30 训练验证分割**（`validation_split=0.3`，推荐启用）：

- 数据按时间切分：前 70% 训练、后 30% 验证
- 在**训练集**上搜索组合（枚举、门槛筛选）
- 在**验证集**上二次过滤：验证集命中率 ≥ 优质门槛才保留
- 最终 `hit_rate` 用**验证集命中率**（更可信），`train_hit_rate` 保留训练集命中率
- **经验**：一开始只用多轮效果有限，加入 70/30 验证后才明显提升，避免过拟合训练段

---

### 3.6 回测（backtester.py）

- 正向递归，不使用未来数据
- 支持做多/做空、**固定止盈止损**（无分段止盈、无时间衰减）
- 配置：`BACKTEST_CONFIG`（`STOP_LOSS_PCT`、`TAKE_PROFIT_PCT` 等）
- 与信号分析 TP/SL 一致：做多 TP +0.6%、SL -0.8%、20x 杠杆

> 注：backtester 内部有 TP1/阶段2/时间衰减等可选逻辑，但当前核心流程与信号分析一致，均使用**固定 TP/SL**。

---

### 3.7 模拟交易（paper_trader + live_trading_engine）

**signal_live_monitor**：每根 K 线收线时，检测 `get_cumulative()` 中的组合是否在 `latest_bar_idx` 全部条件满足，返回触发的 `combo_key` 列表。

**精品信号模式**（`use_signal_mode=True`）：

- 入场：仅当 `SignalLiveMonitor.on_bar()` 返回的组合触发，且满足市场状态、门控等
- 止盈止损：**固定阶梯**（`STAGED_TP_PCT=12%`、`STAGED_SL_PCT=16%`，杠杆后），与回测一致

**paper_trader**：管理虚拟持仓、`update_price()` 检查止盈止损、记录交易。

---

## 四、Pool1 与 Pool2

### 4.1 双池设计 rationale（重要）

两个池子的 TP/SL 与门槛经过**反复验证**后选定，复现时不可随意改动。

**Pool1：非对称止盈止损**

| 方向 | TP（价格%） | SL（价格%） | 含费后随机基准 | 门槛（候选/优质/精品） |
|------|-------------|-------------|----------------|------------------------|
| 做多 | +0.6% | -0.8% | **61%** | 64% / 67% / 71% |
| 做空 | -0.8% | +0.6% | **47%** | 52% / 55% / 59% |

**设计考虑**：
- 做多：止盈窄、止损宽，盈亏比 0.54:0.86（含费），需约 61% 命中率才保本；门槛比基准高 3~10 个百分点
- 做空：止盈宽、止损窄，盈亏比 0.74:0.66，只需约 47% 即可保本；门槛相应降低（52/55/59%）
- 多轮换数据覆盖不同市场阶段，可消除趋势偏差对基准的影响

**Pool2：双向对称止盈止损**

| 方向 | TP（价格%） | SL（价格%） | 含费后随机基准 | 门槛（候选/优质/精品） |
|------|-------------|-------------|----------------|------------------------|
| 做多/做空 | ±1.0% | ±0.8% | **约 47.8%** | 52% / 55% / 59% |

**设计考虑**：
- 双向 TP=1.0%、SL=0.8%，含费后 TP 净 0.94%、SL 净 0.86%，break-even ≈ 47.8%
- 止盈距离更大，单笔盈利更高，但触发难度略增
- 与 Pool1 形成互补：Pool1 偏短线、非对称；Pool2 偏中短线、对称，可覆盖不同风格

**为何选这两个池**：经多轮验证，Pool1 非对称能更好利用做多/做空不同波动特性；Pool2 对称简化逻辑且 break-even 较低。两者配合可扩大策略覆盖、分散风险。

### 4.2 参数与门槛速查

| 项目 | Pool1 | Pool2 |
|------|-------|-------|
| 做多 TP/SL | 0.6% / 0.8% | 1.0% / 0.8% |
| 做空 TP/SL | 0.8% / 0.6% | 1.0% / 0.8% |
| 精品门槛 | 做多 71%，做空 59% | 双向 59% |
| 优质门槛 | 做多 67%，做空 55% | 55% |
| 候选门槛 | 做多 64%，做空 52% | 52% |

### 4.3 分类汇总与 ID 规范（重要）

**原则**：两个池子要做好分类汇总，**既不要冲突也不要减少正确的**。

**round_id**：
- 各池**独立编号**，Pool1 与 Pool2 的 `round_id` 互不干扰
- 每池从 1 递增，`_next_round_id(data)` 基于该池 `rounds` 的最大值 + 1
- 历史记录展示时需分池显示，避免 `round_id` 混在一起

**combo_key**：
- 格式：`"{direction}|{条件1}+{条件2}+..."`（条件按字典序排序）
- 示例：`long|atr_ratio_loose+ma5_slope_dir_strict+vol_ratio_strict`
- 同一组合在 Pool1 与 Pool2 中 **combo_key 相同**，但 TP/SL、命中率不同

**pool_id**：
- 每条 cumulative 条目必须带 `pool_id`（`'pool1'` 或 `'pool2'`）
- 合并两池时若用 `{**cumul1, **cumul2}`，**相同 combo_key 会互相覆盖**，导致丢失一池数据
- **正确做法**：合并时用 `f"{pool_id}|{combo_key}"` 作为键，或分池维护、按需分别查询，确保不覆盖、不减少

**层级与门槛**：
- 计算 tier（候选/优质/精品）时必须用该条目的 `pool_id` 选择对应门槛
- Pool1 做多 64/67/71，做空 52/55/59；Pool2 双向 52/55/59

### 4.4 持仓数量（avg_hold_bars）

**来源**：`signal_analyzer` 每轮分析返回的 `hold_bars` 列表（每触发点的持仓根数，-1 表示超时）。

**聚合**：
- `avg_hold_bars`：所有轮次中**自然结束**（非超时）的持仓根数的**中位数**
- `hold_bars_sample_count`：参与统计的有效样本数
- 超时（`hold_bars[i] == -1`）不参与计算

**用途**：模拟交易中用于时间衰减阈值（如 `decay_bar_1 = avg_hold_bars * 0.5`）、持仓时长参考。

---

## 五、踩过的坑与注意事项

### 5.1 ATR 策略（重要）

**问题**：早期模拟交易曾用 `STOP_LOSS_ATR=2.0`、`TAKE_PROFIT_ATR=3.5` 做动态止盈止损（ATR 倍数）。

**问题点**：

1. **与回测不一致**：信号分析回测用的是**固定价格 %**（TP 0.6%、SL 0.8%），不是 ATR
2. **波动放大**：ATR 波动大时，TP/SL 距离会随市场伸缩，实盘表现与回测偏差大
3. **ATR 缺失**：曾返回 100.0 导致止盈止损过宽，已修复为用 `high-low` 或 `price*0.001` 估算

**当前做法**：精品信号模式使用**固定阶梯止盈止损**（`STAGED_TP_PCT`、`STAGED_SL_PCT`），与回测完全一致，不再用 ATR 动态计算。

**atr_ratio 条件**：在 `signal_analyzer` 中，`atr_ratio = bar_range / atr` 表示「当前 K 线振幅 / ATR」，用于条件过滤（如 `atr_ratio > 1.2` 表示波动放大），这是**信号条件**，不是止盈止损计算方式，两者要区分。

---

### 5.2 70/30 验证分割（重要）

**问题**：一开始只用多轮累积，效果有限，策略在实盘/新数据上泛化差。

**原因**：多轮虽能累积样本，但每轮都在全量数据上搜索，容易过拟合同一时间段。

**正确做法**：启用 70/30 训练验证分割（`validation_split=0.3`）。在训练集搜索组合，用验证集二次过滤，最终 `hit_rate` 取验证集命中率。加入该机制后，验证效果才明显提升。

---

### 5.3 单条件命中率剪枝

**错误做法**：对单条件设命中率门槛（如 >55% 才保留）。

**原因**：数据量大（如 50000 根）时，大数定律使单条件命中率收敛至随机基准（约 57%），命中率剪枝会误杀几乎所有条件。

**正确做法**：只保留 `trigger_count >= MIN_TRIGGERS(8)` 的条件，最终筛选由组合的 64%/67%/71% 门槛完成。

---

### 5.4 同 K 线双触发

若同一根 K 线内 TP 和 SL 同时被触及（如影线先碰 TP 再碰 SL），采用**悲观假设**：一律视为止损（`outcomes[i]=False`）。

---

### 5.5 入场与触发判断

- **入场**：信号 K 线下一根的 `open`（市价单）
- **触发判断**：用 `high`/`low` 判断限价单到价（TP 用 high 触及、SL 用 low 触及）

---

### 5.6 回测精度

- 费率假设：Binance 合约单次往返约 0.06%
- 含费后零期望基准：做多 61%，做空 47%
- 门槛已含费：做多 64%/67%/71%，做空 52%/55%/59%

---

### 5.7 条件数量惩罚

`signal_store` 中，条件数 > 3 时，每多 1 条扣 3 分（防过拟合）。

---

### 5.8 新开仓保护期

保护期内（默认 60 秒）：**阻止亏损止损触发**，**允许止盈触发**，避免噪声波动过早止损。

---

### 5.9 累计结果被覆盖（严重）

**问题**：`signal_store` 的 `rounds` 和 `cumulative` 在未点击「清空记录」的情况下被清空，数据丢失。

**根因**：读写竞争条件。`_load_raw()` 读取文件时**未获取 `_write_lock`**，而 `_save_raw()` 写入时持有锁。当写入与读取并发时：
1. 线程 A 正在写入（持有锁）
2. 线程 B 同时读取同一文件（无需锁）
3. 读取到不完整 JSON → `json.load()` 抛出 `UnicodeDecodeError` 或 `JSONDecodeError`
4. 异常被静默捕获，返回 `_empty_state()`
5. `merge_rounds` 将该空状态写入文件，**覆盖原有数据**

**修复**：
- `_load_raw()`、`_load_cumulative_fast()` 读取时也获取 `_write_lock`，与写入互斥
- 解析失败时优先使用内存缓存，不再静默返回空状态并覆盖
- 新增 `_read_json_file()` 支持 UTF-8/UTF-16 自动识别，避免编码导致的解析失败

**预防**：读写 JSON 状态文件必须加锁；解析失败时**禁止**用空状态覆盖磁盘。

---

### 5.10 combo_key 格式一致性（重要）

**问题**：历史上 cache 曾用 `long:cond1,cond2` 格式，而核心逻辑、`record_live_result` 用 `long|cond1+cond2`。格式不一致导致 `record_live_result` 在 cache 中找不到 entry，**live_tracking（实盘命中率、连亏次数）永不更新**。

**正确做法**：全链路统一用 `_combo_key(direction, conditions)` 生成的 `|+` 格式。`_normalize_all_entries` 写入 cache 时也必须用 `_combo_key`，不能自创 `:,` 格式。

---

### 5.11 MAX_HOLD 与超时

- `MAX_HOLD=60`（短线优化），在 `entry_idx` 到 `entry_idx+60` 内未触及 TP/SL 则**超时**，算未命中
- 超时点 `hold_bars[i]=-1`，不参与 `avg_hold_bars` 统计
- 修改 MAX_HOLD 需同步考虑：预计算复杂度、超时比例、持仓时长假设

---

### 5.12 低样本警告（low_sample_warn）

- 触发次数 8–14 时标记 `low_sample_warn=True`，仍可入选，但需警惕过拟合
- 建议：多轮验证、70/30 分割后，仍对低样本组合谨慎使用

---

### 5.13 JSON 文件编码

- 若 state/cache 被外部工具保存为 UTF-16，`json.load` 会报 `UnicodeDecodeError: 0xff`
- 已加 `_read_json_file` 自动识别 UTF-8/UTF-16；**写入时应统一用 UTF-8**，避免跨环境问题

---

### 5.14 费率假设

- 单次往返约 0.06%（Binance 合约），从 TP 净收益扣、叠到 SL 净亏损
- 含费基准（61%/47%/47.8%）和门槛均基于此。若实盘费率不同，需调整基准或门槛

---

### 5.15 备份与恢复

- 定期用「备份 GitHub」或「导入数据」备份；清空后可从 `data/github_backup/` 或 git 历史恢复
- 导入时合并逻辑：rounds 按 `(timestamp, direction)` 去重，cumulative 按 combo_key 合并 history

---

## 六、不包含的功能（复现时可忽略）

- **指纹图 / 向量空间**：已淘汰
- **自适应**：`ADAPTIVE_ENABLED=False`、`KELLY_ENABLED=False`、`KELLY_ADAPTATION_ENABLED=False` 等
- **Walk-Forward 进化**：可选，非核心流程
- **追踪止盈**：`TRAILING_STOP_ENABLED=False`，当前用固定阶梯

---

## 七、关键配置速查（config.py）

```python
# 信号分析
MAX_HOLD = 60                    # 最大持仓根数
LONG_TP1_PCT = 0.006   # 做多 TP +0.6%
LONG_SL_PCT  = 0.008   # 做多 SL -0.8%
SHORT_TP1_PCT = 0.008  # 做空 TP -0.8%
SHORT_SL_PCT  = 0.006  # 做空 SL +0.6%
MIN_TRIGGERS = 8

# Pool2
POOL2_LONG_TP_PCT = 0.010
POOL2_LONG_SL_PCT = 0.008
POOL2_SHORT_TP_PCT = 0.010
POOL2_SHORT_SL_PCT = 0.008
POOL2_TIER_CANDIDATE = 0.52
POOL2_TIER_QUALITY   = 0.55
POOL2_TIER_PREMIUM   = 0.59

# 模拟交易（精品信号模式）
STAGED_TP_PCT = 12.0   # 杠杆后 +12%
STAGED_SL_PCT = 16.0   # 杠杆后 -16%
STAGED_TP_RATIO_1 = 0.70  # TP1 平 70%
```

---

## 八、复现检查清单

1. [ ] 实现 `_precompute_outcomes`：固定 TP/SL，逐 bar 判断止盈/止损先触发
2. [ ] 实现 30 个条件数组（`_build_condition_arrays`）
3. [ ] 单条件预剪枝：仅 `trigger_count >= 8`，不做命中率剪枝
4. [ ] 组合枚举 + 门槛筛选（64/67/71 做多，52/55/59 做空）
5. [ ] 多轮合并：`merge_rounds` + `history` 累积
6. [ ] 去重：规范化、冗余子集剪枝、锚点分组
7. [ ] 回测：固定 TP/SL，与信号分析一致
8. [ ] 模拟交易：`SignalLiveMonitor` 检测触发 + 固定阶梯止盈止损
9. [ ] **不要**用 ATR 动态计算 TP/SL（与回测不一致）
10. [ ] **signal_store 读写**：`_load_raw`/`_load_cumulative_fast` 必须与 `_save_raw` 共用同一锁，解析失败时禁止用空状态覆盖磁盘（见 5.9）
11. [ ] **双池分类汇总**：`round_id` 各池独立；合并时用 `pool_id|combo_key` 或分池查询，避免覆盖；每条 entry 带 `pool_id`；tier 计算用对应池门槛（见 4.3）
12. [ ] **持仓数量**：`avg_hold_bars` 取自然结束持仓根数的中位数，超时（-1）不参与（见 4.4）
13. [ ] **70/30 验证**：启用 `validation_split=0.3`，训练集搜索、验证集二次过滤，避免仅多轮过拟合（见 3.5、5.2）
14. [ ] **双池 TP/SL**：Pool1 非对称（做多 0.6/0.8、做空 0.8/0.6），Pool2 对称（1.0/0.8），含费基准与门槛见 4.1，勿随意改动
15. [ ] **combo_key 格式**：全链路统一 `|+` 格式（`_combo_key`），cache 写入勿用 `:,`，否则 live_tracking 不更新（见 5.10）
16. [ ] **定期备份**：清空不可恢复，建议定期备份；可从 github_backup 或 git 恢复（见 5.15）

---

*文档版本：2026-02-22*
